# Напишите функцию filtered.cor которая на вход получает data.frame с  произвольным количеством переменных (как количественными, 
# так и любых других типов), рассчитывает коэффициенты корреляции Пирсона между всеми парами количественных переменных и возвращает наибольшее по модулю 
# значение коэффициента корреляции. (То есть функция может вернуть -0.9, если это наибольшая по модулю  корреляция).

# Гарантируется наличие в data.frame хотя бы двух количественных переменных.
# Обратите внимание: при проверке вашей функции на вход будут подаваться данные с различными именами колонок. 
# Ваша функция должна корректно работать независимо от имен переменных. Перед тем, как сдавать решение, убедитесь, 
# что ваша функция работает корректно на разных данных, с разными именами колонок. 

# Если вы хотите использовать функцию corr.test не забудьте загрузить библиотекy psych.




library(psych) #подгружаем пакет psych

filtered.cor <- function(x){
z<- corr.test(x[ ,sapply(x,is.numeric)]) # x[ ,sapply(x,is.numeric) это отбор только числовых данных
diag(z$r)<-0 # z$r имеет структуру матрицы. С помощью функции diag() извлекаем диагональ матрицы (единицы).
if (abs(min(z$r))>max(z$r)) { #тк максимальное значение может быть и отрицательным, проводим сранение max r положительного и отрицательно. Решил циклом, но есть и более красивый вариант x[which.max(abs(x))].
    return(min(z$r))}
    else {
        return(max(z$r))}
}
